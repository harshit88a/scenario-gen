
SYSTEM ROLE: You are an expert Autonomous Vehicle Simulation Engineer specializing in the Scenic 3.0.0 programming language and CARLA 0.9.15. Your task is to generate valid Scenic code for adversarial scenarios based on Scenario Description provided below.

CRITICAL RULES - YOU MUST FOLLOW THESE EXACTLY:
1. ONLY USE methods, classes, and blueprints that appear in the few-shot examples below.
2. NEVER invent or hallucinate any classes, methods, or blueprints that are not in the examples.
3. NEVER use deprecated Scenic syntax - only use patterns shown in the examples.
4. ONLY use CARLA blueprints that appear in the examples (e.g., vehicle.lincoln.mkz_2017, walker.pedestrian.0001).
5. ONLY use Scenic behaviors that appear in the examples (e.g., BehaviorType, Follow, FollowLaneBehavior).
6. All scenarios must use Town05 map.
7. Output MUST have exactly four labeled sections as shown below.

OUTPUT FORMAT - DO NOT DEVIATE:
# 1. MAP AND MODEL CONFIGURATION
# 2. ADV BEHAVIOR OF THE SURROUNDING OBJECT
# 3. ROAD GEOMETRY
# 4. RELATIVE SPAWN POSITION OF THE ADVERSARIAL AGENT

FEW-SHOT EXAMPLES (SOURCE OF TRUTH - ONLY USE THESE):

Example 1 (Description: Ego vehicle goes straight at a 3-way intersection. An adversary vehicle makes a left turn from a conflicting lane. The Ego must brake suddenly to avoid a collision.):
```scenic
# Scenario: Ego vehicle goes straight at a 3-way intersection. An adversary vehicle makes a left turn from a conflicting lane. The Ego must brake suddenly to avoid a collision.

## 1. MAP AND MODEL CONFIGURATION
param map = localPath('./../CARLA_0.9.15/CarlaUE4/Content/Carla/Maps/OpenDrive/Town05.xodr')
param carla_map = 'Town05'
param use2DMap = True
model scenic.simulators.carla.model

# Constants
param EGO_SPEED = Range(8, 12)
param ADV_SPEED = Range(10, 14)
param SAFETY_DIST = Range(8, 12)
param BRAKE_INTENSITY = 1.0

## 2. ADV BEHAVIOR OF THE SURROUNDING OBJECT

behavior EgoBehavior(trajectory):
    try:
        do FollowTrajectoryBehavior(target_speed=globalParameters.EGO_SPEED, trajectory=trajectory)
    interrupt when withinDistanceToAnyObjs(self, globalParameters.SAFETY_DIST):
        take SetBrakeAction(globalParameters.BRAKE_INTENSITY)

behavior AdversaryBehavior(trajectory):
    do FollowTrajectoryBehavior(target_speed=globalParameters.ADV_SPEED, trajectory=trajectory)

monitor GreenWave():
    freezeTrafficLights()
    while True:
        if withinDistanceToTrafficLight(ego, 100):
            setClosestTrafficLightStatus(ego, "green")
        wait

## 3. ROAD GEOMETRY
EGO_MODEL = "vehicle.lincoln.mkz_2017"
ADV_MODEL = "vehicle.tesla.model3"

# Helper to find valid Straight vs Left Turn pairs at 3-way intersections
def get_conflict_pairs(intersections):
    pairs = []
    for intersec in intersections:
        # Get all Straight maneuvers (Potential Ego)
        straights = filter(lambda m: m.type == ManeuverType.STRAIGHT, intersec.maneuvers)
        
        for s in straights:
            # Find Left Turns that conflict with this Straight maneuver
            # We look inside s.conflictingManeuvers for Left Turns
            conflicts = filter(lambda c: c.type == ManeuverType.LEFT_TURN, s.conflictingManeuvers)
            
            for c in conflicts:
                pairs.append([s, c])
    return pairs

# A. Find all 3-way intersections
three_way_intersections = filter(lambda i: i.is3Way, network.intersections)

# B. Pre-calculate valid maneuver pairs to avoid RandomControlFlowError
valid_pairs = get_conflict_pairs(three_way_intersections)

# Requirement: Ensure we found at least one valid configuration in the map
require len(valid_pairs) > 0

# C. Select one pair Uniformly
selected_pair = Uniform(*valid_pairs)
ego_maneuver = selected_pair[0]
adv_maneuver = selected_pair[1]

# D. Define Trajectories
ego_trajectory = [ego_maneuver.startLane, ego_maneuver.connectingLane, ego_maneuver.endLane]
adv_trajectory = [adv_maneuver.startLane, adv_maneuver.connectingLane, adv_maneuver.endLane]

## 4. RELATIVE SPAWN POSITION OF THE ADVERSARIAL AGENT
param EGO_DIST_TO_INTERSECTION = Range(15, 25)
param ADV_DIST_TO_INTERSECTION = Range(15, 20)

# 1. Define Anchor Points (The intersection entry points)
# Using .points[-1] of the start lane centerline gives us the stop line/entry point
ego_anchor = new OrientedPoint at ego_maneuver.startLane.centerline.points[-1]
adv_anchor = new OrientedPoint at adv_maneuver.startLane.centerline.points[-1]

# 2. Define Spawn Points relative to the Anchors (Negative distance = upstream)
ego_spawn_pt = new OrientedPoint following roadDirection from ego_anchor for -globalParameters.EGO_DIST_TO_INTERSECTION
adv_spawn_pt = new OrientedPoint following roadDirection from adv_anchor for -globalParameters.ADV_DIST_TO_INTERSECTION

# 3. Instantiate Agents
ego = new Car at ego_spawn_pt offset by (0, 0, 0.5),
    with blueprint EGO_MODEL,
    with behavior EgoBehavior(ego_trajectory)

adversary = new Car at adv_spawn_pt offset by (0, 0, 0.5),
    with blueprint ADV_MODEL,
    with behavior AdversaryBehavior(adv_trajectory)

# Requirements and Termination
require monitor GreenWave()
terminate when (distance to ego_spawn_pt) > 80
```

Example 2 (Description: Ego vehicle drives straight; adversarial pedestrian appears from behind a parked car on the right and suddenly stops in the lane.):
```scenic
# Scenario: Ego vehicle drives straight; adversarial pedestrian appears from behind a parked car on the right and suddenly stops in the lane.

## 1. MAP AND MODEL CONFIGURATION
param map = localPath('./../CARLA_0.9.15/CarlaUE4/Content/Carla/Maps/OpenDrive/Town05.xodr')
param carla_map = 'Town05'
param use2DMap = True
model scenic.simulators.carla.model

# Standard behaviors
from scenic.simulators.carla.behaviors import FollowLaneBehavior, CrossingBehavior
# Action for the parked car
from scenic.simulators.carla.actions import SetHandBrakeAction

## 2. ADV BEHAVIOR OF THE SURROUNDING OBJECT
param EGO_SPEED = Range(8, 12)
param PED_SPEED = 2.0
param PED_WALK_DURATION = 2.0

# Ego: Simply follows the lane
behavior EgoBehavior(target_speed):
    do FollowLaneBehavior(target_speed=target_speed)

# Parked Car: Uses HandBrake (Boolean) to stay stationary
behavior ParkedBehavior():
    take SetHandBrakeAction(True)

# Pedestrian: Walks using CrossingBehavior with a time limit
behavior CrossAndFreeze(ego, speed, duration):
    # FIX: Pass 'lambda: ego' because the error suggested CrossingBehavior calls the ego argument.
    # We use a large threshold (300) to ensure the pedestrian starts walking immediately regardless of ego distance.
    do CrossingBehavior(lambda: ego, speed, 300) for duration seconds
    
    # Upon timeout, terminate. 
    # In CARLA/Scenic, terminating the behavior usually leaves the agent with the last control state 
    # or zeroed controls depending on the bridge. Without SetSpeed, this is the safest stop.
    terminate

## 3. ROAD GEOMETRY
EGO_MODEL = "vehicle.lincoln.mkz_2017"
PARKED_MODEL = "vehicle.nissan.patrol"
PED_MODEL = "walker.pedestrian.0001"

# 1. Select a lane
initLane = Uniform(*network.lanes)

# 2. Create Ego Spawn Point
ego_spawn_pt = new OrientedPoint on initLane.centerline

# 3. Define Parked Car Position (Occluder)
# Located ahead of the Ego, shifted to the right (shoulder/parking zone)
parked_spawn_pt = new OrientedPoint right of ego_spawn_pt by 3.5

# Requirement: Ensure the spawn is not too close to an intersection
require (distance from ego_spawn_pt to intersection) > 50

## 4. RELATIVE SPAWN POSITION OF THE ADVERSARIAL AGENT
param PARKED_DIST = Range(25, 35)
param PED_DIST_FROM_CAR = 4.0 

# 1. Update Parked Car location longitudinally
parked_spot = new OrientedPoint following roadDirection from parked_spawn_pt for globalParameters.PARKED_DIST

# 2. Create Pedestrian Spawn Point
# The pedestrian spawns 'behind' the parked car (relative to Ego's view)
# We offset slightly right (0.5m) to ensure they start fully behind the car body
ped_ref_spot = new OrientedPoint following roadDirection from parked_spot for globalParameters.PED_DIST_FROM_CAR
ped_spawn_pt = new OrientedPoint right of ped_ref_spot by 0.5

# 3. Instantiate Agents

# Ego Vehicle
ego = new Car at ego_spawn_pt offset by (0, 0, 0.5),
    with blueprint EGO_MODEL,
    with behavior EgoBehavior(globalParameters.EGO_SPEED)

# Parked Car (The Occluder)
parked_car = new Car at parked_spot offset by (0, 0, 0.5),
    with blueprint PARKED_MODEL,
    with behavior ParkedBehavior()

# Adversarial Pedestrian
# facing 90 deg
```

Example 3 (Description: Ego vehicle performs a lane change to bypass a slow  adversary vehicle but cannot return to its original lane because the adversary accelerates. Ego vehicle must then slow down to avoid  collision with leading vehicle in new lane.):
```scenic
# Scenario: Ego vehicle performs a lane change to bypass a slow  adversary vehicle but cannot return to its original lane because the adversary accelerates. Ego vehicle must then slow down to avoid  collision with leading vehicle in new lane.


## 1. MAP AND MODEL CONFIGURATION
param map = localPath('../CARLA_0.9.15/CarlaUE4/Content/Carla/Maps/OpenDrive/Town05.xodr')
param carla_map = 'Town05'
param use2DMap = True
model scenic.simulators.carla.model

## 2. ADV BEHAVIOR OF THE SURROUNDING OBJECT
# Constants for speeds (m/s) and distances (m)
param EGO_SPEED = 12
param ADV_INIT_SPEED = 5
param ADV_END_SPEED = 15     # Adversary speeds up to block return
param LEAD_SPEED = 6         # Slow lead in the new lane
param TRIGGER_DIST = 15      # Distance to trigger lane change
param SAFETY_DIST = 12       # Distance to trigger braking behind lead

behavior AdversaryBehavior():
    do FollowLaneBehavior(target_speed=globalParameters.ADV_INIT_SPEED) until \
        (self.lane != ego.lane)
    do FollowLaneBehavior(target_speed=globalParameters.ADV_END_SPEED)

behavior LeadBehavior():
    do FollowLaneBehavior(target_speed=globalParameters.LEAD_SPEED)

behavior EgoBehavior(target_section):
    do FollowLaneBehavior(target_speed=globalParameters.EGO_SPEED) until \
        (distance to adversary) < globalParameters.TRIGGER_DIST

    do LaneChangeBehavior(laneSectionToSwitch=target_section, target_speed=globalParameters.EGO_SPEED)

    try:
        do FollowLaneBehavior(target_speed=globalParameters.EGO_SPEED)
    interrupt when (distance to lead) < globalParameters.SAFETY_DIST:
        take SetBrakeAction(1.0)

## 3. ROAD GEOMETRY
EGO_MODEL = "vehicle.lincoln.mkz_2017"

# 1. Pick a lane
initLane = Uniform(*network.lanes)

# 2. Pick a point on that lane
spawnPt = new OrientedPoint on initLane.centerline

# CRITICAL FIX: Filter this random point *immediately* before defining dependent variables
require (distance from spawnPt to intersection) > 50

# 3. Define the spatial query for the target lane (Left)
checkPt = new OrientedPoint left of spawnPt by 3.5
targetSection = network.laneSectionAt(checkPt)

# 4. Filter the target section
require targetSection is not None
require targetSection.lane != initLane

# 5. Spawn Ego
ego = new Car at spawnPt offset by (0, 0, 0.5),
    with blueprint EGO_MODEL,
    with behavior EgoBehavior(targetSection)

## 4. RELATIVE SPAWN POSITION OF THE ADVERSARIAL AGENT
param ADV_DIST = Range(15, 20)
param LEAD_DIST = Range(35, 45)

# Spawn Adversary
adv_spot = new OrientedPoint following roadDirection from spawnPt for globalParameters.ADV_DIST
adversary = new Car at adv_spot offset by (0, 0, 0.5),
    with blueprint EGO_MODEL,
    with behavior AdversaryBehavior()

# Spawn Lead
lead_spot = new OrientedPoint following roadDirection from checkPt for globalParameters.LEAD_DIST
lead = new Car at lead_spot offset by (0, 0, 0.5),
    with blueprint EGO_MODEL,
    with behavior LeadBehavior()

# Final checks for agents
require (distance from adversary to intersection) > 20
require (distance from lead to intersection) > 20
```


IMPORTANT: Generate code that closely mimics the structure and patterns from the examples above. Do not introduce new methods or classes.

TASK: Generate the Scenic code for the following scenario description. Follow the four-section format exactly.

SCENARIO DESCRIPTION: The ego vehicle is following an adversarial car and its suddenly breaks causing collision with ego vehicle.

Generate the Scenic code:
